<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Device Leveling Tool</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            transition: background-color 0.5s ease-in-out;
            touch-action: none; /* Prevents default browser actions on touch */
        }

        .animated-line {
            transition: transform 0.1s linear;
        }

        .animated-square {
            transition: background-color 0.3s ease-in-out, transform 0.3s ease-in-out;
        }

        .debug {
            position: absolute;
            bottom: 8px;
            left: 8px;
            font-size: 12px;
            opacity: 0.6;
        }
    </style>
</head>
<body class="bg-slate-900 text-white flex flex-col items-center justify-center h-screen overflow-hidden">
    <!-- Main content area for the leveling tool -->
    <div class="flex flex-col items-center justify-center w-full h-full relative p-4">

        <!-- Informational text and status messages -->
        <div id="status-message" class="absolute top-4 w-full text-center text-sm sm:text-base md:text-lg">
            Align your phone to level ground.
        </div>

        <!-- Stationary center guideline (stays at middle) -->
        <div id="center-line" class="absolute w-full h-0.5 bg-gray-600/70" style="top: 50%; transform: translateY(-50%);"></div>

        <!-- Reactive line that moves with device pitch (behind the square) -->
        <div id="reference-line" class="animated-line absolute w-full h-1 bg-gray-500 rounded-full z-0" style="top: 50%;"></div>
        
        <!-- The square in the center (above lines) -->
        <div id="reference-square" class="animated-square w-32 h-32 md:w-48 md:h-48 rounded-lg bg-gray-500 z-10"></div>

        <!-- A simple info box for permission/enable scenarios -->
        <div id="no-sensor-info" class="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 text-center p-4 bg-gray-800 rounded-lg shadow-lg">
            <h2 class="text-xl font-bold mb-2">Enable Motion Sensors</h2>
            <p class="mb-3">Tap the button below to enable device motion. Some browsers require a user gesture.</p>
            <button id="enable-btn" class="px-4 py-2 bg-purple-600 rounded-md font-semibold">Enable Motion</button>
            <p class="mt-2 text-xs opacity-80">On iOS, you may also need to allow Motion & Orientation access in Settings.</p>
        </div>

        <div id="debug" class="debug hidden"></div>
    </div>

    <script>
        // Get references to the elements
        const refLine = document.getElementById('reference-line');
        const centerLine = document.getElementById('center-line');
        const refSquare = document.getElementById('reference-square');
        const statusMessage = document.getElementById('status-message');
        const noSensorInfo = document.getElementById('no-sensor-info');
        const enableBtn = document.getElementById('enable-btn');
        const debugEl = document.getElementById('debug');

        // Tolerance for "perfect" alignment in degrees
        const levelTolerance = 0.5;
        const maxOffsetVh = 40; // how far the reactive line can move from center

        // Initial state
        let isLeveled = false;

        // Util: update UI
        function updateUI(betaDeg) {
            // Clamp
            const adjustedBeta = Math.max(-90, Math.min(90, betaDeg));
            const linePosition = (-adjustedBeta / 90) * maxOffsetVh;
            refLine.style.transform = `translate3d(0, ${linePosition}vh, 0)`;
            debugEl.textContent = `beta: ${betaDeg.toFixed(1)}Â°`;

            if (Math.abs(adjustedBeta) < levelTolerance) {
                if (!isLeveled) {
                    refSquare.classList.remove('bg-gray-500');
                    refSquare.classList.add('bg-purple-600', 'scale-125');
                    refLine.classList.remove('bg-gray-500');
                    refLine.classList.add('bg-yellow-400');
                    statusMessage.textContent = "Perfectly Aligned!";
                    isLeveled = true;
                }
            } else if (isLeveled) {
                refSquare.classList.remove('bg-purple-600', 'scale-125');
                refSquare.classList.add('bg-gray-500');
                refLine.classList.remove('bg-yellow-400');
                refLine.classList.add('bg-gray-500');
                statusMessage.textContent = "Align your phone to level ground.";
                isLeveled = false;
            }
        }

        // Function to handle the device orientation event
        function handleOrientation(event) {
            // Check if the sensor data is valid before proceeding
            if (event.beta === null || event.beta === undefined) {
                return;
            }
            
            // Beta represents the front-to-back tilt (horizontal axis rotation)
            const beta = event.beta; // degrees
            updateUI(beta);
        }

        // Fallback using DeviceMotion (accelerometer) to compute pitch
        function handleMotion(event) {
            const acc = event.accelerationIncludingGravity;
            if (!acc) return;
            const ax = acc.x || 0;
            const ay = acc.y || 0;
            const az = acc.z || 0;
            // Estimate pitch (front-back tilt). Different devices axes vary with orientation.
            // Use atan2 of -ax and sqrt(ay^2 + az^2) to approximate pitch in radians.
            const pitchRad = Math.atan2(-ax, Math.hypot(ay, az));
            const pitchDeg = pitchRad * (180 / Math.PI);
            updateUI(pitchDeg);
        }

        // Start sensors after user gesture (required by many browsers)
        function startSensors() {
            // iOS permission flow
            const request = window.DeviceOrientationEvent && DeviceOrientationEvent.requestPermission;
            if (typeof request === 'function') {
                DeviceOrientationEvent.requestPermission().then(state => {
                    if (state === 'granted') {
                        window.addEventListener('deviceorientation', handleOrientation, true);
                        window.addEventListener('devicemotion', handleMotion, true);
                        noSensorInfo.classList.add('hidden');
                        debugEl.classList.remove('hidden');
                    }
                }).catch(() => {});
            } else {
                // Android/others: enable listeners directly
                window.addEventListener('deviceorientation', handleOrientation, true);
                window.addEventListener('devicemotion', handleMotion, true);
                noSensorInfo.classList.add('hidden');
                debugEl.classList.remove('hidden');
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            enableBtn.addEventListener('click', startSensors);
        });
    </script>
</body>
</html>
